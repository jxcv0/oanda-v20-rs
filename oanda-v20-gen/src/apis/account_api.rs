/*
 * OANDA v20 API
 *
 * The full OANDA v20 API Specification. This specification defines how to interact with v20 Accounts, Trades, Orders, Pricing and more.
 *
 * The version of the OpenAPI document: 3.0.25
 * Contact: api@oanda.com
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`configure_account`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ConfigureAccountError {
    Status400(models::AccountConfigurationBadRequestResponse),
    Status401(),
    Status403(models::AccountConfigurationForbiddenResponse),
    Status404(),
    Status405(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_account`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAccountError {
    Status400(models::Error400),
    Status401(),
    Status405(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_account_changes`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAccountChangesError {
    Status401(),
    Status404(),
    Status405(),
    Status416(models::Error416),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_account_instruments`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAccountInstrumentsError {
    Status400(),
    Status401(),
    Status405(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_account_summary`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAccountSummaryError {
    Status400(),
    Status401(),
    Status405(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_accounts`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAccountsError {
    Status401(models::Error401),
    Status405(models::Error405),
    UnknownValue(serde_json::Value),
}


/// Set the client-configurable portions of an Account.
pub async fn configure_account(configuration: &configuration::Configuration, account_id: &str, accept_datetime_format: Option<models::DateTimeFormat>, account_configuration_request: Option<models::AccountConfigurationRequest>) -> Result<models::AccountConfigurationResponse, Error<ConfigureAccountError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_account_id = account_id;
    let p_accept_datetime_format = accept_datetime_format;
    let p_account_configuration_request = account_configuration_request;

    let uri_str = format!("{}/accounts/{accountId}/configuration", configuration.base_path, accountId=crate::apis::urlencode(p_account_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_accept_datetime_format {
        req_builder = req_builder.header("Accept-Datetime-Format", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_account_configuration_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AccountConfigurationResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AccountConfigurationResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ConfigureAccountError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the full details for a single Account that a client has access to. Full pending Order, open Trade and open Position representations are provided.
pub async fn get_account(configuration: &configuration::Configuration, account_id: &str, accept_datetime_format: Option<models::DateTimeFormat>) -> Result<models::AccountResponse, Error<GetAccountError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_account_id = account_id;
    let p_accept_datetime_format = accept_datetime_format;

    let uri_str = format!("{}/accounts/{accountId}", configuration.base_path, accountId=crate::apis::urlencode(p_account_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_accept_datetime_format {
        req_builder = req_builder.header("Accept-Datetime-Format", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AccountResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AccountResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetAccountError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Endpoint used to poll an Account for its current state and changes since a specified TransactionID.
pub async fn get_account_changes(configuration: &configuration::Configuration, account_id: &str, accept_datetime_format: Option<models::DateTimeFormat>, since_transaction_id: Option<i32>) -> Result<models::AccountChangesResponse, Error<GetAccountChangesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_account_id = account_id;
    let p_accept_datetime_format = accept_datetime_format;
    let p_since_transaction_id = since_transaction_id;

    let uri_str = format!("{}/accounts/{accountId}/changes", configuration.base_path, accountId=crate::apis::urlencode(p_account_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_since_transaction_id {
        req_builder = req_builder.query(&[("sinceTransactionID", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_accept_datetime_format {
        req_builder = req_builder.header("Accept-Datetime-Format", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AccountChangesResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AccountChangesResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetAccountChangesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the list of tradeable instruments for the given Account. The list of tradeable instruments is dependent on the regulatory division that the Account is located in, thus should be the same for all Accounts owned by a single user.
pub async fn get_account_instruments(configuration: &configuration::Configuration, account_id: &str, instruments: Option<Vec<models::InstrumentName>>) -> Result<models::AccountInstrumentsResponse, Error<GetAccountInstrumentsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_account_id = account_id;
    let p_instruments = instruments;

    let uri_str = format!("{}/accounts/{accountId}/instruments", configuration.base_path, accountId=crate::apis::urlencode(p_account_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_instruments {
        req_builder = match "csv" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("instruments".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("instruments", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AccountInstrumentsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AccountInstrumentsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetAccountInstrumentsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a summary for a single Account that a client has access to.
pub async fn get_account_summary(configuration: &configuration::Configuration, account_id: &str, accept_datetime_format: Option<models::DateTimeFormat>) -> Result<models::AccountSummaryResponse, Error<GetAccountSummaryError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_account_id = account_id;
    let p_accept_datetime_format = accept_datetime_format;

    let uri_str = format!("{}/accounts/{accountId}/summary", configuration.base_path, accountId=crate::apis::urlencode(p_account_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_accept_datetime_format {
        req_builder = req_builder.header("Accept-Datetime-Format", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AccountSummaryResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AccountSummaryResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetAccountSummaryError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a list of all Accounts authorized for the provided token.
pub async fn get_accounts(configuration: &configuration::Configuration, ) -> Result<models::AccountsResponse, Error<GetAccountsError>> {

    let uri_str = format!("{}/accounts", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AccountsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AccountsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetAccountsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

